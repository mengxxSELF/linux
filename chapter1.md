# chapter1  文件系统

## 用户身份

Linux 是一个多用户环境，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统

而每个用户都属于一个用户组

所以系统一共有三种角色： 文件所有者、用户组、其他人

![users](https://user-gold-cdn.xitu.io/2018/12/17/167bbfd8bf78ab0e?w=786&h=546&f=png&s=402390)


## 权限

权限有三种： r 读 w 写 x 执行

对于不同的对象这些有不同的含义

* 文件

r 代表是否能查看文件的内容
w 代表能否对文件的内容进行操作，但是不能删除文件
x 代表这个文件能否被执行

* 目录

r 表示可以读取目录结构列表
w 表示具有更改目录列表的权限(创建、删除、移动、重命名文件)
x 表示用户能否进入目录 比如 cd 进入此目录


### 修改权限

chgrp xxx filename	改变文件所属用户组
chown xxx filename	改变文件所有者
chmod xxx filename	改变文件的权限

修改权限可以使用数字或者字符

1 使用数值  ( r 4 w 2 x 1)  

```js
chmod 7 read.md
```

2 使用字符  u g o 代表三种身份的权限  

```js
chown u=rwx,go=rx readme.md
```

-----------------------

Q: 文件创建时候的默认权限是什么

A： 取决于 umask

-----------------------

#### umask

umask是用来指定当前用户在新建目录或文件时的权限预设值

可以分数形式和字符形式展示

umask分数值是一个掩码，【是创建文件时的默认权限要减去的权限】

分数展示的时候，请忽略第一位，那一个是特殊权限

默认权限的属性，文件和目录是不同的

* 用户创建一般文件，则默认取消可执行权限，即666（rw-rw-rw-）

* 用户创建目录文件，由于x与是否可以进入此目录有关，因此默认开放所有权限，即777（rwxrwxrwx）

![umask](https://user-gold-cdn.xitu.io/2018/12/17/167bc096bbf4c8c1?w=896&h=314&f=png&s=352615)

可以调整 umask 的值

```js
umask 0001
```
![umask](https://user-gold-cdn.xitu.io/2018/12/17/167bc0c68850f8c7?w=1024&h=304&f=png&s=339525)


## 文件系统

####  FHS

文件配置标准 - FHS - Filesystem Hierarchy Standard

js中有一个概念，万物皆对象。在Linux中，有一个类似的概念， 万物皆文件，所有的都是一个文件 比如设备 进程等

之前有提到 其实是有多种 Linux distribution的 不同的类型之间其实大致相同, 比如配置文件  执行文件 操作目录是大体一致的 如果你从centos 迁移到 utunb  不会有很大的差异感 这个是因为开发者所遵循的一个文件配置规则  -- FHS

FHS 规定了文件系统的基本配置目录，主要有三个 / 根目录 /var /usr 

| 目录 | 含义  |
| --- | --- | --- | --- |
| / (root 根目录) | 与开机系统有关系 |
| /usr | 与软件的安装、执行有关系 |
| /var | 与系统运作过程有关系 |


这里讲几个比较常见的目录

* 根目录


| 目录 | 文件内容 |
|----|----|
| /bin | 执行文件，在/bin 下的命令 可以被root和一般账号使用,比如 cat cp等 |
|/etc|系统主要配置文件，例如账号密码文件，何种服务的启示文件|
|/tmp| 正在执行的程序放置文件的地方 FHS建议在开机时将 /tmp下的数据删除 |


* /usr  

这个目录的全程是 unix software source
就是一些与软件相关的程序目录

#### $PATH

为什么在任何一个位置都可以可以执行 ls 命令

1 ls 是一个可执行文件
2 根源在 /bin/ls （也就是执行ls 与执行 /bin/ls 是同样的效果）
3 问题变为，为什么随时可以执行 /bin/ls 这个文件
4 系统按照 PATH 的设置 在每一个 path的定义目录下 查询名为ls的可执行文件
5 先找到的被执行

命令行输入 查看path

```js
echo $PATH
```

![path](https://user-gold-cdn.xitu.io/2018/12/18/167c0c4de9eda1d7?w=923&h=111&f=png&s=163456)



## 文件操作

对于文件/目录的增删改查

增 mkdir touch  cp

mkdir 添加 p 可以一次性创建多层目录

```js
mkdir -p dir1/dir2/dir3
```

复制目录 一般目录会包含文件 所以需要使用 fr 递归进行文件的复制

```js
cp -fr dir
```

删 rm 

```js
rm -fr dir
```

改 vim 

查 find where  ls


切换文件目录 cd

有时候进入用户主目录可以直接使用

```js
cd ~
```


## 磁盘

一个文件包含文件权限(rwx)与文件属性(拥有者、群组、时间参数等)
文件系统通常会将这两部份的数据分别存放在不同的区块，权限与属性放置到 inode 中，至于实际数据则放置到 data block 区块中

文件名，记录在该文件所在目录的目录文件的block中

* 文件系统一开始就将 inode 与 block 规划好了，除非重新格式化，否则 inode 与 block 固定后就不再变动
1 原则上，block 的大小与数量在格式化完就不能够再改变了(除非重新格式化)
2 每个 block 内最多只能够放置一个文件的数据
3 承上，如果文件大于 block 的大小，则一个文件会占用多个 block 数量
4 承上，若文件小于 block ，则该 block 的剩余容量就不能够再被使用了(磁盘空间会浪费)

------------------
Q: 为什么 删除或者变更文件名 需要对这个文件所在的目录具有 w 权限？

A: 文件名的记录是在目录的block当中

------------------


创建一个文件后，文件完整信息分布在3处地方，生成2个新文件：
3.1 文件名记录在该文件所在目录的目录文件的block中，没有新文件生成
3.2 文件属性、权限信息、记录具体内容的block编号记录在inode中，inode是新生成文件
3.3 文件具体内容记录在block中，block是新生成文件

* 文件系统和内存的关系

所有的数据都得要加载到内存后 ，CPU 才能够对该数据进行处理
想一想，如果你常常编辑一个好大的文件， 在编辑的过程中又频繁的要系统来写入到磁盘中，由于磁盘写入的速度要比内存慢很多， 因此你会常常耗在等待硬盘的写入/读取

Linux 使用异步处理 (asynchronously) 的方式来解决这个问题

当系统加载一个文件到内存后，如果该文件没有被更动过，则在内存区段的文件数据是干净(clean)状态， 但如果内存中的文件数据被更改过了(例如你用 nano 去编辑过这个文件)，此时该内存中的数据会为 (Dirty)状态。此时所有的动作都还在内存中运行，并没有写入到磁盘中。系统会不定时的将内存中『Dirty』的数据写回磁盘，以保持磁盘与内存数据的一致性

（正常关机时，关机命令会使用 sync 来将内存的数据回写入磁盘内）

由于内存的速度要比硬盘快的多，因此如果能够将常用的文件放置到内存当中，这样就会大大提升系统性能
